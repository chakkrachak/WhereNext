// This file was generated by json2swift. https://github.com/ijoshsmith/json2swift

import Foundation

//
// MARK: - Data Model
//
struct RootType: CreatableFromJSON { // TODO: Rename this struct
    let disruptions: [Any?]
    let feedPublishers: [FeedPublishers]
    let links: [Links]
    let places: [Places]
    init(disruptions: [Any?], feedPublishers: [FeedPublishers], links: [Links], places: [Places]) {
        self.disruptions = disruptions
        self.feedPublishers = feedPublishers
        self.links = links
        self.places = places
    }
    init?(json: [String: Any]) {
        guard let disruptions = json["disruptions"] as? [Any?] else { return nil }
        guard let feedPublishers = FeedPublishers.createRequiredInstances(from: json, arrayKey: "feed_publishers") else { return nil }
        guard let links = Links.createRequiredInstances(from: json, arrayKey: "links") else { return nil }
        guard let places = Places.createRequiredInstances(from: json, arrayKey: "places") else { return nil }
        self.init(disruptions: disruptions, feedPublishers: feedPublishers, links: links, places: places)
    }
    struct FeedPublishers: CreatableFromJSON { // TODO: Rename this struct
        let id: String
        let license: String
        let name: String
        let url: URL
        init(id: String, license: String, name: String, url: URL) {
            self.id = id
            self.license = license
            self.name = name
            self.url = url
        }
        init?(json: [String: Any]) {
            guard let id = json["id"] as? String else { return nil }
            guard let license = json["license"] as? String else { return nil }
            guard let name = json["name"] as? String else { return nil }
            guard let url = URL(json: json, key: "url") else { return nil }
            self.init(id: id, license: license, name: name, url: url)
        }
    }
    struct Links: CreatableFromJSON { // TODO: Rename this struct
        let href: String
        let rel: String
        let templated: Bool
        let type: String
        init(href: String, rel: String, templated: Bool, type: String) {
            self.href = href
            self.rel = rel
            self.templated = templated
            self.type = type
        }
        init?(json: [String: Any]) {
            guard let href = json["href"] as? String else { return nil }
            guard let rel = json["rel"] as? String else { return nil }
            guard let templated = json["templated"] as? Bool else { return nil }
            guard let type = json["type"] as? String else { return nil }
            self.init(href: href, rel: rel, templated: templated, type: type)
        }
    }
    struct Places: CreatableFromJSON { // TODO: Rename this struct
        let embeddedType: String
        let id: String
        let name: String
        let quality: Int
        let stopArea: StopArea
        init(embeddedType: String, id: String, name: String, quality: Int, stopArea: StopArea) {
            self.embeddedType = embeddedType
            self.id = id
            self.name = name
            self.quality = quality
            self.stopArea = stopArea
        }
        init?(json: [String: Any]) {
            guard let embeddedType = json["embedded_type"] as? String else { return nil }
            guard let id = json["id"] as? String else { return nil }
            guard let name = json["name"] as? String else { return nil }
            guard let quality = json["quality"] as? Int else { return nil }
            guard let stopArea = StopArea(json: json, key: "stop_area") else { return nil }
            self.init(embeddedType: embeddedType, id: id, name: name, quality: quality, stopArea: stopArea)
        }
        struct StopArea: CreatableFromJSON { // TODO: Rename this struct
            let administrativeRegions: [AdministrativeRegions]
            let codes: [Codes]
            let coord: Coord
            let id: String
            let label: String
            let links: [Any?]
            let name: String
            let timezone: String
            init(administrativeRegions: [AdministrativeRegions], codes: [Codes], coord: Coord, id: String, label: String, links: [Any?], name: String, timezone: String) {
                self.administrativeRegions = administrativeRegions
                self.codes = codes
                self.coord = coord
                self.id = id
                self.label = label
                self.links = links
                self.name = name
                self.timezone = timezone
            }
            init?(json: [String: Any]) {
                guard let administrativeRegions = AdministrativeRegions.createRequiredInstances(from: json, arrayKey: "administrative_regions") else { return nil }
                guard let codes = Codes.createRequiredInstances(from: json, arrayKey: "codes") else { return nil }
                guard let coord = Coord(json: json, key: "coord") else { return nil }
                guard let id = json["id"] as? String else { return nil }
                guard let label = json["label"] as? String else { return nil }
                guard let links = json["links"] as? [Any?] else { return nil }
                guard let name = json["name"] as? String else { return nil }
                guard let timezone = json["timezone"] as? String else { return nil }
                self.init(administrativeRegions: administrativeRegions, codes: codes, coord: coord, id: id, label: label, links: links, name: name, timezone: timezone)
            }
            struct AdministrativeRegions: CreatableFromJSON { // TODO: Rename this struct
                let coord: Coord
                let id: String
                let insee: String
                let label: String
                let level: Int
                let name: String
                let zipCode: String
                init(coord: Coord, id: String, insee: String, label: String, level: Int, name: String, zipCode: String) {
                    self.coord = coord
                    self.id = id
                    self.insee = insee
                    self.label = label
                    self.level = level
                    self.name = name
                    self.zipCode = zipCode
                }
                init?(json: [String: Any]) {
                    guard let coord = Coord(json: json, key: "coord") else { return nil }
                    guard let id = json["id"] as? String else { return nil }
                    guard let insee = json["insee"] as? String else { return nil }
                    guard let label = json["label"] as? String else { return nil }
                    guard let level = json["level"] as? Int else { return nil }
                    guard let name = json["name"] as? String else { return nil }
                    guard let zipCode = json["zip_code"] as? String else { return nil }
                    self.init(coord: coord, id: id, insee: insee, label: label, level: level, name: name, zipCode: zipCode)
                }
                struct Coord: CreatableFromJSON { // TODO: Rename this struct
                    let lat: String
                    let lon: String
                    init(lat: String, lon: String) {
                        self.lat = lat
                        self.lon = lon
                    }
                    init?(json: [String: Any]) {
                        guard let lat = json["lat"] as? String else { return nil }
                        guard let lon = json["lon"] as? String else { return nil }
                        self.init(lat: lat, lon: lon)
                    }
                }
            }
            struct Codes: CreatableFromJSON { // TODO: Rename this struct
                let type: String
                let value: String
                init(type: String, value: String) {
                    self.type = type
                    self.value = value
                }
                init?(json: [String: Any]) {
                    guard let type = json["type"] as? String else { return nil }
                    guard let value = json["value"] as? String else { return nil }
                    self.init(type: type, value: value)
                }
            }
            struct Coord: CreatableFromJSON { // TODO: Rename this struct
                let lat: String
                let lon: String
                init(lat: String, lon: String) {
                    self.lat = lat
                    self.lon = lon
                }
                init?(json: [String: Any]) {
                    guard let lat = json["lat"] as? String else { return nil }
                    guard let lon = json["lon"] as? String else { return nil }
                    self.init(lat: lat, lon: lon)
                }
            }
        }
    }
}

//
// MARK: - JSON Utilities
//
/// Adopted by a type that can be instantiated from JSON data.
protocol CreatableFromJSON {
    /// Attempts to configure a new instance of the conforming type with values from a JSON dictionary.
    init?(json: [String: Any])
}

extension CreatableFromJSON {
    /// Attempts to configure a new instance using a JSON dictionary selected by the `key` argument.
    init?(json: [String: Any], key: String) {
        guard let jsonDictionary = json[key] as? [String: Any] else { return nil }
        self.init(json: jsonDictionary)
    }

    /// Attempts to produce an array of instances of the conforming type based on an array in the JSON dictionary.
    /// - Returns: `nil` if the JSON array is missing or if there is an invalid/null element in the JSON array.
    static func createRequiredInstances(from json: [String: Any], arrayKey: String) -> [Self]? {
        guard let jsonDictionaries = json[arrayKey] as? [[String: Any]] else { return nil }
        return createRequiredInstances(from: jsonDictionaries)
    }

    /// Attempts to produce an array of instances of the conforming type based on an array of JSON dictionaries.
    /// - Returns: `nil` if there is an invalid/null element in the JSON array.
    static func createRequiredInstances(from jsonDictionaries: [[String: Any]]) -> [Self]? {
        var array = [Self]()
        for jsonDictionary in jsonDictionaries {
            guard let instance = Self.init(json: jsonDictionary) else { return nil }
            array.append(instance)
        }
        return array
    }

    /// Attempts to produce an array of instances of the conforming type, or `nil`, based on an array in the JSON dictionary.
    /// - Returns: `nil` if the JSON array is missing, or an array with `nil` for each invalid/null element in the JSON array.
    static func createOptionalInstances(from json: [String: Any], arrayKey: String) -> [Self?]? {
        guard let array = json[arrayKey] as? [Any] else { return nil }
        return createOptionalInstances(from: array)
    }

    /// Attempts to produce an array of instances of the conforming type, or `nil`, based on an array.
    /// - Returns: An array of instances of the conforming type and `nil` for each invalid/null element in the source array.
    static func createOptionalInstances(from array: [Any]) -> [Self?] {
        return array.map { item in
            if let jsonDictionary = item as? [String: Any] {
                return Self.init(json: jsonDictionary)
            }
            else {
                return nil
            }
        }
    }
}

extension Date {
    // Date formatters are cached because they are expensive to create. All cache access is performed on a serial queue.
    private static let cacheQueue = DispatchQueue(label: "DateFormatterCacheQueue")
    private static var formatterCache = [String: DateFormatter]()
    private static func dateFormatter(with format: String) -> DateFormatter {
        if let formatter = formatterCache[format] { return formatter }
        let formatter = DateFormatter()
        formatter.dateFormat = format
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.calendar = Calendar(identifier: .gregorian)
        formatter.timeZone = TimeZone(secondsFromGMT: 0)! // UTC is assumed, but won't interfere with a format-specified time zone.
        formatterCache[format] = formatter
        return formatter
    }

    static func parse(string: String, format: String) -> Date? {
        var formatter: DateFormatter!
        cacheQueue.sync { formatter = dateFormatter(with: format) }
        return formatter.date(from: string)
    }

    init?(json: [String: Any], key: String, format: String) {
        guard let string = json[key] as? String else { return nil }
        guard let date = Date.parse(string: string, format: format) else { return nil }
        self.init(timeIntervalSinceReferenceDate: date.timeIntervalSinceReferenceDate)
    }
}

extension URL {
    init?(json: [String: Any], key: String) {
        guard let string = json[key] as? String else { return nil }
        self.init(string: string)
    }
}

extension Double {
    init?(json: [String: Any], key: String) {
        // Explicitly unboxing the number allows an integer to be converted to a double,
        // which is needed when a JSON attribute value can have either representation.
        guard let nsNumber = json[key] as? NSNumber else { return nil }
        self.init(_: nsNumber.doubleValue)
    }
}

extension Array where Element: NSNumber {
    // Convert integers to doubles, for example [1, 2.0] becomes [1.0, 2.0]
    // This is necessary because ([1, 2.0] as? [Double]) yields nil.
    func toDoubleArray() -> [Double] {
        return map { $0.doubleValue }
    }
}

extension Array where Element: CustomStringConvertible {
    func toDateArray(withFormat format: String) -> [Date]? {
        var dateArray = [Date]()
        for string in self {
            guard let date = Date.parse(string: String(describing: string), format: format) else { return nil }
            dateArray.append(date)
        }
        return dateArray
    }

    func toURLArray() -> [URL]? {
        var urlArray = [URL]()
        for string in self {
           guard let url = URL(string: String(describing: string)) else { return nil }
           urlArray.append(url)
        }
        return urlArray
    }
}

extension Array where Element: Any {
    func toOptionalValueArray<Value>() -> [Value?] {
        return map { ($0 is NSNull) ? nil : ($0 as? Value) }
    }

    func toOptionalDateArray(withFormat format: String) -> [Date?] {
        return map { item in
            guard let string = item as? String else { return nil }
            return Date.parse(string: string, format: format)
        }
    }

    func toOptionalDoubleArray() -> [Double?] {
        return map { item in
            guard let nsNumber = item as? NSNumber else { return nil }
            return nsNumber.doubleValue
        }
    }

    func toOptionalURLArray() -> [URL?] {
        return map { item in
            guard let string = item as? String else { return nil }
            return URL(string: string)
        }
    }
}
